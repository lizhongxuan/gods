
## 创建型设计模式
### singleton 单例模式
如果有些数据只应该保存一份

### factory 工厂模式
用于创建同一类型的不同类的对象

分类:
简单工厂: 适用于类型改动不频繁的情况
工厂方法: 适用于对象创建逻辑比较复杂的情况
抽象工厂: 适用于同时创建有关联的多个不同类型的对象
DI容器:  自动创建对象,一般在框架中使用较多

何时使用：我们明确地计划不同条件下创建不同实例时。
如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。
应用实例：您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。

### builder 建造者模式
建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
适用于类的属性编辑多,存在必选以及非必选或者其他较为负载的约束条件的情况

何时使用：一些基本部件不会变，而其组合经常变化的时候。
如何解决：将变与不变分离开。
应用实例：去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"

### prototype 原型模式
原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
适用于对象的创建成本较大,并且创建出的对象直接的差别较小的情况

主要解决：在运行期建立和删除原型。
如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。
关键代码：实现克隆操作


## 结构式模式
### proxy 代理模式
一个类代表另一个类的功能
意图：为其他对象提供一种代理以控制对这个对象的访问。


### Bridge 桥接模式
意图：将抽象部分与实现部分分离，使它们都可以独立的变化。
主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。
何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。

### Decorator 装饰器模式
允许向一个现有的对象添加新的功能，同时又不改变其结构。

意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。
何时使用：在不想增加很多子类的情况下扩展类。

### Adapter 适配器模式
意图：将不兼容的接口转换为可兼容的接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

### Facade 外观模式(门面模式)
隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。减少系统相互依赖.

意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。
何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。
应用实例： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。

### Composite 组合模式
又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。

意图：将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。
应用实例：公司的人员组织就是一个典型的树状的结构，现在假设我们现在有部分和员工，两种角色，一个部门下面可以存在子部门和员工，员工下面不能再包含其他节点。.

### Flyweight 享元模式
主要用于减少创建对象的数量，以减少内存占用和提高性能。

主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

## 行为型模式
### observer 观察者模式
观察者模式使得一种类型的实例可以发送事件给其他类型，前提是接收事件的实例要根发送者订阅这个事件。

主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

### Template 模板模式
意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

主要解决：一些方法通用，却在每一个子类都重新写了这一方法。

### strategy 策略模式
策略模式可以让更换对象的内脏，而装饰者模式可以更换对象的外表。一个类的行为或其算法可以在运行时更改。

意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。
何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。

### chaim 职责链模式
将请求的发送和接收解耦,让多个接收对象都有机会处理这个请求.将这些接收对象串成一条链,并沿着这条链传递这个请求,知道链上的某个接收对象能够处理它为止.

场景: 过滤器

### state 状态模式
通过将事件触发的状态转移和动作执行,拆分到不同的状态类中,来避免分支判断逻辑
通过函数改变成其他接口类,来控制不同状态的逻辑


### iterator 迭代器
迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。
迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。
然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。





